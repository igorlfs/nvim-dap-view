<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<link rel="icon" href="https://fav.farm/ğŸ˜" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	
		<link href="./_app/immutable/assets/0.CY-wNcS-.css" rel="stylesheet">
		<link rel="modulepreload" href="./_app/immutable/entry/start.BSTjOFIo.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/BFvg6U5t.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/Bg0Y8X25.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/CjpeB9No.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DPEja5KE.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/CYgJF_JY.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DFAO5y1m.js">
		<link rel="modulepreload" href="./_app/immutable/entry/app.7Y7RhZ5I.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DNMWFP0k.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/Dic1KHAO.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/BVYR4rSG.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/D149APHh.js">
		<link rel="modulepreload" href="./_app/immutable/nodes/0.DsIH6arH.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DaVKATEZ.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DD6pV2wQ.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DhbAx3b5.js">
		<link rel="modulepreload" href="./_app/immutable/nodes/3.dg64N9pJ.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/D2VCOvFc.js"><!--[--><meta property="og:type" content="article"> <meta property="og:title" content="Using Neovim as a terminal multiplexer"><!--]--><title>Using Neovim as a terminal multiplexer</title>
</head>

<body data-sveltekit-preload-data="hover" class="bg-base">
	<div style="display: contents"><!--[--><!--[--><!----><div class="flex flex-col min-h-screen justify-between"><div><nav class="bg-crust p-2"><div class="flex justify-between xl:px-36 sm:px-16 px-4 items-center min-h-10"><a class="text-xl text-accent" href="./">IgorLFS</a> <ul><!--[--><li class="gap-5 uppercase"><a href="./about" title="About">About</a></li><!--]--></ul></div></nav><!----> <main><!----><div class="text-text pb-8 my-10 flex justify-center"><article class="xl:w-[60%] w-[90%]"><hgroup><h1 class="capitalize sm:text-5xl text-3xl font-bold text-primary">Using Neovim as a terminal multiplexer</h1> <!--[--><p class="mt-2 text-subtext">Oct 13, 2024</p><!--]--></hgroup> <div class="flex gap-4 mt-3"><!--[--><span class="rounded-3xl bg-crust px-3 py-2">#neovim</span><span class="rounded-3xl bg-crust px-3 py-2">#software</span><!--]--></div> <div class="prose lg:prose-xl max-w-none"><!----><blockquote><p><strong>Guide assumes youâ€™re using neovim 0.11+</strong></p></blockquote> <p>One of the main features of a terminal multiplexer is that they can spawn multiple â€œwindowsâ€. Of course, a powerful multiplexer can offer much more, with detachable sessions and so on, but I would assume the most common use case for a multiplexer is plainly itâ€™sâ€¦ â€œmultiplexingâ€ capability. If youâ€™re currently using a multiplexer mainly for this reason and youâ€™re a bit unhappy with your current setup, and if you also happen to be a neovim user, this guide was made specifically for you! Letâ€™s explore neovimâ€™s builtin functionalities to build a poor manâ€™s tmux!</p> <p>For as long as Iâ€™ve been using vim, Iâ€™ve been using its tab functionality. And honestly, Iâ€™m surprised with how often itâ€™s overlooked. Tabs in vim are slightly different from traditional tabs found in other programs: a tab can show <em>multiple</em> windows in any arrangement. When you launch vim with a file as an argument, you create a tab containing a single window. You can, then, manipulate the windows using commands such as <code>:split</code>, to split your screen horizontally, creating another â€œviewâ€ (window) for your current file. There are plenty of window commands to do the most common operations one would expect from aâ€¦ window manager. You can read more about them with <code>:h CTRL-W</code>.</p> <p>Thereâ€™s another concept in vim that often gets mixed up with tabs: buffers. A buffer is the in-memory representation of a file. But many people, usually coming from other editors, think that vimâ€™s tabs should behave as a â€œcollection of buffersâ€ (i.e., a list with the files that are currently open). Many plugins mimic this behavior (a popular one is <a href="https://github.com/akinsho/bufferline.nvim" rel="nofollow">bufferline</a>). And if that fits your workflow, fantastic! But I find vanilla vim tabs the most powerful. A common use case is to create a tab for each project youâ€™re working on, so you can have a single neovim instance[^1] do all the work. That sure sounds multiplexy!</p> <p>However, weâ€™ll follow a different approach. I like to have a single neovim instance for each project Iâ€™m working on, and each neovim instance has its own tabs. To me, each tab is kinda like a â€œmental stateâ€. To explain that, Iâ€™ll use the neovim instance Iâ€™m using to write this blog post: I have 5 tabs open, some contain posts, another one contains 2 CSS-related files (I need to tweak some stuff, but I donâ€™t wanna deal with that right now), and the last one is a terminal running <code>vite dev</code> to run the blog. All of these tabs have a â€œmeaningâ€ that would be otherwise messy to manage without using tabs. Of course, the neovim community has built dozens of plugins to â€œmanageâ€ the usage of multiple files. A popular option is <a href="https://github.com/ThePrimeagen/harpoon" rel="nofollow">harpoon</a>. Again, if youâ€™re happy using harpoon (or any of the alternatives), fantastic! But I find these solutions to be a bit â€œoverengineeredâ€.</p> <p>The wise among you may have noticed I havenâ€™t talked about the usage of vimâ€™s tabs just yet. Thatâ€™s because I find the default bindings to be rather non-ergonomic. Letâ€™s take a look at the navigation: you can use <code>gt</code> to go the next tab and <code>gT</code> to go to the previous tab. Most vim mappings can be repeated when preceded with a number: you can use <code>10ifoo</code> in normal mode to insert the word â€œfooâ€ 10 times[^2]. By that logic, if you were to use <code>2gt</code>, one would expect to go 2 tabs forward, but what happens is that you jump to the second tab, regardless of how many tabs you have open (which is a little weird, but not a big deal). What I annoys me the most is that Iâ€™m often switching tabs, so much so that pressing <em>those</em> 3 keys feels like too much effort. Surprisingly, Chrome comes to the rescue! Most popular browsers allow navigating between tabs using <code>&lt;A-[x]</code>, where <code>[x]</code> is the tabâ€™s number. So I borrowed that for my config, as follows:</p> <!----><pre class="shiki catppuccin-mocha" style="background-color:#1e1e2e;color:#cdd6f4" tabindex="0"><code><span class="line"><span style="color:#CBA6F7">local</span><span style="color:#CDD6F4"> str </span><span style="color:#94E2D5">=</span><span style="color:#89B4FA;font-style:italic"> string.format</span></span>
<span class="line"></span>
<span class="line"><span style="color:#CBA6F7">for</span><span style="color:#CDD6F4"> i </span><span style="color:#94E2D5">=</span><span style="color:#FAB387"> 1</span><span style="color:#CDD6F4">, </span><span style="color:#FAB387">9</span><span style="color:#CBA6F7"> do</span></span>
<span class="line"><span style="color:#CDD6F4"> vim.keymap.</span><span style="color:#89B4FA;font-style:italic">set</span><span style="color:#CDD6F4">(</span><span style="color:#A6E3A1">"n"</span><span style="color:#CDD6F4">, </span><span style="color:#89B4FA;font-style:italic">str</span><span style="color:#CDD6F4">(</span><span style="color:#A6E3A1">"&#x3C;A-%s>"</span><span style="color:#CDD6F4">, i), </span><span style="color:#89B4FA;font-style:italic">str</span><span style="color:#CDD6F4">(</span><span style="color:#A6E3A1">"%sgt"</span><span style="color:#CDD6F4">, i), &#123; desc </span><span style="color:#94E2D5">=</span><span style="color:#89B4FA;font-style:italic"> str</span><span style="color:#CDD6F4">(</span><span style="color:#A6E3A1">"Goto tab %s"</span><span style="color:#CDD6F4">, i) &#125;)</span></span>
<span class="line"><span style="color:#CBA6F7">end</span></span></code></pre><!----> <p>I have decided to adopt the <code>Alt</code> key as a â€œtab modifierâ€ and also introduced some other mappings:</p> <!----><pre class="shiki catppuccin-mocha" style="background-color:#1e1e2e;color:#cdd6f4" tabindex="0"><code><span class="line"><span style="color:#CDD6F4">vim.keymap.</span><span style="color:#89B4FA;font-style:italic">set</span><span style="color:#CDD6F4">(</span><span style="color:#A6E3A1">"n"</span><span style="color:#CDD6F4">, </span><span style="color:#A6E3A1">"&#x3C;A-0>"</span><span style="color:#CDD6F4">, </span><span style="color:#A6E3A1">"&#x3C;CMD>tablast&#x3C;CR>"</span><span style="color:#CDD6F4">, &#123; desc </span><span style="color:#94E2D5">=</span><span style="color:#A6E3A1"> "Goto last tab" </span><span style="color:#CDD6F4">&#125;)</span></span>
<span class="line"><span style="color:#CDD6F4">vim.keymap.</span><span style="color:#89B4FA;font-style:italic">set</span><span style="color:#CDD6F4">(</span><span style="color:#A6E3A1">"n"</span><span style="color:#CDD6F4">, </span><span style="color:#A6E3A1">"&#x3C;A-]>"</span><span style="color:#CDD6F4">, </span><span style="color:#A6E3A1">"&#x3C;CMD>tabnext&#x3C;CR>"</span><span style="color:#CDD6F4">, &#123; desc </span><span style="color:#94E2D5">=</span><span style="color:#A6E3A1"> "Goto next tab" </span><span style="color:#CDD6F4">&#125;)</span></span>
<span class="line"><span style="color:#CDD6F4">vim.keymap.</span><span style="color:#89B4FA;font-style:italic">set</span><span style="color:#CDD6F4">(</span><span style="color:#A6E3A1">"n"</span><span style="color:#CDD6F4">, </span><span style="color:#A6E3A1">"&#x3C;A-[>"</span><span style="color:#CDD6F4">, </span><span style="color:#A6E3A1">"&#x3C;CMD>tabprevious&#x3C;CR>"</span><span style="color:#CDD6F4">, &#123; desc </span><span style="color:#94E2D5">=</span><span style="color:#A6E3A1"> "Goto prev tab" </span><span style="color:#CDD6F4">&#125;)</span></span>
<span class="line"><span style="color:#CDD6F4">vim.keymap.</span><span style="color:#89B4FA;font-style:italic">set</span><span style="color:#CDD6F4">(</span><span style="color:#A6E3A1">"n"</span><span style="color:#CDD6F4">, </span><span style="color:#A6E3A1">"&#x3C;A-->"</span><span style="color:#CDD6F4">, </span><span style="color:#A6E3A1">"&#x3C;CMD>tabm-&#x3C;CR>"</span><span style="color:#CDD6F4">, &#123; desc </span><span style="color:#94E2D5">=</span><span style="color:#A6E3A1"> "Move tab to the left" </span><span style="color:#CDD6F4">&#125;)</span></span>
<span class="line"><span style="color:#CDD6F4">vim.keymap.</span><span style="color:#89B4FA;font-style:italic">set</span><span style="color:#CDD6F4">(</span><span style="color:#A6E3A1">"n"</span><span style="color:#CDD6F4">, </span><span style="color:#A6E3A1">"&#x3C;A-=>"</span><span style="color:#CDD6F4">, </span><span style="color:#A6E3A1">"&#x3C;CMD>tabm+&#x3C;CR>"</span><span style="color:#CDD6F4">, &#123; desc </span><span style="color:#94E2D5">=</span><span style="color:#A6E3A1"> "Move tab to the right" </span><span style="color:#CDD6F4">&#125;)</span></span>
<span class="line"><span style="color:#CDD6F4">vim.keymap.</span><span style="color:#89B4FA;font-style:italic">set</span><span style="color:#CDD6F4">(</span><span style="color:#A6E3A1">"n"</span><span style="color:#CDD6F4">, </span><span style="color:#A6E3A1">"&#x3C;A-'>"</span><span style="color:#CDD6F4">, </span><span style="color:#A6E3A1">"&#x3C;CMD>tab split&#x3C;CR>"</span><span style="color:#CDD6F4">, &#123; desc </span><span style="color:#94E2D5">=</span><span style="color:#A6E3A1"> "Clone window in new tab" </span><span style="color:#CDD6F4">&#125;)</span></span></code></pre><!----> <p>The last one is particularly useful when ones wants to â€œtemporally maximizeâ€ a window, by creating a new tab.</p> <p>A final note on tabs is that the default <code>tabline</code> is a bit ugly. And by â€œa bit uglyâ€ I mean that it has some limitations and itâ€™s clunky. Fortunately, like everything else in vim, itâ€™s customizable. Writing your own <code>tabline</code> is doable (I used to have mine), but itâ€™s easier with a plugin. The one I use is <a href="https://github.com/nanozuki/tabby.nvim" rel="nofollow">tabby.nvim</a>[^3]. Its biggest selling point is that tab names are made unique if theyâ€™d otherwise share the same name. Thatâ€™s a massive help when browsing a Rust codebase with lots of <code>mod.rs</code> or a SvelteKit project with lots of <code>+page.svelte</code>.</p> <p>Now that weâ€™ve covered (almost) everything about â€œmultiplexingâ€, letâ€™s talk some â€œterminalâ€!</p> <p>Iâ€™d argue neovimâ€™s builtin terminal also lacks some usability. The default experience can be quite confusing, in fact. It goes like this: a new user hears about using a terminal directly inside of neovim. They decide to try it for themselves and promptly run a <code>:terminal</code>. The terminal shows up and, in true vim spirit, they enter â€œinsertâ€[^4] mode with <code>i</code>. They run some commands, but once they try to go back to normal mode, they realize that <code>&lt;ESC></code> isnâ€™t working and they have to use a weird key combo (<code>&lt;C-\>&lt;C-N></code>) instead. Now, Iâ€™m no expert, but I donâ€™t find that very intuitive. Donâ€™t get me wrong, Iâ€™m sure thereâ€™s a good reason for that to be the default behavior, and Iâ€™m not advocating for a change. As a workaround, what we can do instead is create a new keymap:</p> <!----><pre class="shiki catppuccin-mocha" style="background-color:#1e1e2e;color:#cdd6f4" tabindex="0"><code><span class="line"><span style="color:#CDD6F4">vim.keymap.</span><span style="color:#89B4FA;font-style:italic">set</span><span style="color:#CDD6F4">(</span><span style="color:#A6E3A1">"t"</span><span style="color:#CDD6F4">, </span><span style="color:#A6E3A1">"&#x3C;Esc>"</span><span style="color:#CDD6F4">, </span><span style="color:#A6E3A1">[[&#x3C;C-\>&#x3C;C-n>]]</span><span style="color:#CDD6F4">, &#123; desc </span><span style="color:#94E2D5">=</span><span style="color:#A6E3A1"> "Exit Terminal" </span><span style="color:#CDD6F4">&#125;)</span></span></code></pre><!----> <p>There are some other quirks with <code>:terminal</code> (in spite of the <a href="https://github.com/neovim/neovim/pull/31443" rel="nofollow">great improvement</a> with neovim 0.11). Namely, if youâ€™re using the <code>scrolloff</code> option, you might wanna disable it inside terminals. It behaves inconsistently between modes: it doesnâ€™t work inside terminal mode, and may cause undesired scrolling. You can disable it with an <code>autocmd</code>:</p> <!----><pre class="shiki catppuccin-mocha" style="background-color:#1e1e2e;color:#cdd6f4" tabindex="0"><code><span class="line"><span style="color:#CDD6F4">vim.api.</span><span style="color:#89B4FA;font-style:italic">nvim_create_autocmd</span><span style="color:#CDD6F4">(</span><span style="color:#A6E3A1">"Termopen"</span><span style="color:#CDD6F4">, &#123;</span></span>
<span class="line"><span style="color:#89B4FA;font-style:italic"> callback</span><span style="color:#94E2D5"> =</span><span style="color:#CBA6F7"> function</span><span style="color:#9399B2">()</span></span>
<span class="line"><span style="color:#CDD6F4">  vim.wo[</span><span style="color:#FAB387">0</span><span style="color:#CDD6F4">][</span><span style="color:#FAB387">0</span><span style="color:#CDD6F4">].scrolloff </span><span style="color:#94E2D5">=</span><span style="color:#FAB387"> 0</span></span>
<span class="line"><span style="color:#CBA6F7"> end</span><span style="color:#CDD6F4">,</span></span>
<span class="line"><span style="color:#CDD6F4">&#125;)</span></span></code></pre><!----> <p>Itâ€™s also worth noting that it would be pretty annoying to have to type <code>:terminal</code> every time we were to spawn a terminal. Thereâ€™s a shorthand for that, <code>:term</code>, but itâ€™s in no way short enough. Luckily, again, we can solve this issue with a keymap:</p> <!----><pre class="shiki catppuccin-mocha" style="background-color:#1e1e2e;color:#cdd6f4" tabindex="0"><code><span class="line"><span style="color:#CDD6F4">vim.keymap.</span><span style="color:#89B4FA;font-style:italic">set</span><span style="color:#CDD6F4">(</span><span style="color:#A6E3A1">"n"</span><span style="color:#CDD6F4">, </span><span style="color:#A6E3A1">"&#x3C;C-w>e"</span><span style="color:#CDD6F4">, </span><span style="color:#A6E3A1">"&#x3C;CMD>term&#x3C;CR>"</span><span style="color:#CDD6F4">, &#123; desc </span><span style="color:#94E2D5">=</span><span style="color:#A6E3A1"> "Terminal" </span><span style="color:#CDD6F4">&#125;)</span></span></code></pre><!----> <p>And now weâ€™re done with configuring the terminal! Now you can mix and match terminals, tabs and whatnot. Of course, you could have a â€œmultiplexing experienceâ€ without leveraging the power of tabs (some do), since vim offers many ways to manipulate windows. But to me, the job is so much easier with tabs.</p> <p>Before we continue, thereâ€™s another important limitation of neovimâ€™s terminal that you should be aware of: using the shellâ€™s builtin vi mode gets awkward. To the point where I prefer the default, emacs-like mode of <a href="https://fishshell.com/" rel="nofollow">fish</a>. To me, this isnâ€™t much of a big deal, but I can see how this would impact someoneâ€™s workflow.</p> <p>Letâ€™s talk about some alternatives to using the builtin terminal that also arenâ€™t based on an actual multiplexer. For the longest time, I used to have a â€œfloating terminalâ€ plugin. A common option is <a href="https://github.com/akinsho/toggleterm.nvim" rel="nofollow">toggleterm.nvim</a>. Under the hood, these use the builtin terminal, but without the default cumbersomeness. But now that you know you can have a decent experience without a plugin (and also without having too much trouble), why bother with a plugin?</p> <p>On the other hand, others prefer the builtin functionality from the shell, by suspending neovim[^5] with <code>&lt;C-z></code>, running the desired commands and then bringing neovim back with <code>fg</code>. This is nice, but I see some shortcomings: what if you need to run a command that takes too long to finish? Or what if itâ€™s a build related command you always want to be running? Of course, there are numerous ways to deal with these issues, but by using <code>:term</code> you avoid them altogether. Although, once more: if youâ€™re happy with <code>&lt;C-z></code>, great!</p> <p>Before wrapping up this post I need to address two other factors that heavily influence the usability of this workflow. The first one is that it would be a pain in the ass to manage a bunch of neovim (<a href="https://github.com/neovide/neovide" rel="nofollow">neovide</a>) instances without a decent window manager. If youâ€™re not using a tiling window manager, I can see how easily it would be to get lost if you had a bunch of <em>neovims</em> lying around. With <a href="https://hyprland.org/" rel="nofollow">Hyprland</a> I donâ€™t have to worry about that: I use a workspace for each neovim instance. This setup isnâ€™t perfect (sometimes itâ€™s hard to remember which workspace holds the instance Iâ€™m looking for), but it gets the job done most of the time.</p> <p>Another reasonable concern isâ€¦ Quitting neovim. Seriously. Letâ€™s say youâ€™re quite comfortable with a bunch of tabs and terminals and so on. It would be infuriating if, once you quit neovim, all those arrangements were gone. Fortunately it doesnâ€™t have to be this way. We can use sessions. Sessions are a native feature of vim that allows you to save the state of the editor when you quit[^6]. To make experience smoother, I use a session plugin that allows me to search sessions and save additional data (e.g., breakpoints): <a href="https://github.com/jedrzejboczar/possession.nvim" rel="nofollow">possession.nvim</a>. I wonâ€™t go into detail on how to use the plugin, but it should be straightforward.</p> <p>And thatâ€™s it! Weâ€™ve built a poor manâ€™s tmux using neovim! Thanks for reading! Check out my <a href="https://github.com/igorlfs/dotfiles" rel="nofollow">dotfiles</a> to have a look at the actual implementation for this workflow.</p> <p>[^1]: Neovim is even friendly to this use case, as it exposes commands such as <code>:tcd</code> to change the directory for the current tab only.
[^2]: Thatâ€™s a silly example, but you know the drill ;)
[^3]: The folks from <code>tabby.nvim</code> do a good job of explaining (in the README) how tabs can be powerful.
[^4]: Yes, itâ€™s the â€œTerminalâ€ mode, but from a new userâ€™s perspective it <em>feels</em> like insert mode.
[^5]: Or any other command, really. An advantage of this approach is how agnostic it is.
[^6]: Obviously, you can save your state whenever you want. It just makes more sense when youâ€™re leaving.</p><!----><!----></div></article></div><!----><!----></main></div> <nav class="bg-mantle min-h-4 p-2"><ul class="text-subtext text-sm flex justify-center gap-2"><li><a href="https://github.com/igorlfs" target="_blank">GitHub</a></li> <li><a href="mailto:igorlfs@ufmg.com" target="_blank">Contact</a></li></ul></nav><!----></div><!----><!--]--> <!--[!--><!--]--><!--]-->
			
			<script>
				{
					__sveltekit_18enfys = {
						base: new URL(".", location).pathname.slice(0, -1),
						assets: "/igorlfs.github.io"
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("./_app/immutable/entry/start.BSTjOFIo.js"),
						import("./_app/immutable/entry/app.7Y7RhZ5I.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 3],
							data: [null,null],
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
</body>

</html>
